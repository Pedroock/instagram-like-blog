O PROJETO É FAZER UM SITE IGUAL O INSTAGRAM, E AQUI EU QUERO FAZER TIPO UM ROADMAP.
O BASICO VAI SER CRIAR O SISTEMA LOGIN, VAMO DAR UMA OLHADA NAS DOC DO MODEL USER NO DJANGO E VAMOS CRIAR TAMBÉM O SIGNAL DO PROFILE PRA OS DOIS VIR JUNTOS, VAMOS CRIAR O BÁSICO E DPS ADICIONAR ALGO CASO SEJA NECESSARIO.   >>>FEITO<<<
VAMOS CRIAR UM SISTEMA DE POSTS, QUE VAI TER A DESCRIÇÃO E UMA FOTO E UM CRIADOR. E VAMOS FAZER AS FORMS PARA CRIAR O POST.   >>>FEITO<<<
VAMOS FAZER O ESQUEMA DE SEGUIDORES E VAMOS USAR AJAX PARA FAZER O SITE RESPONDER VISUALMENTE AO CLICK.   >>>FEITO<<<
VAMOS CRIAR LIKES E COMMENTS PARA POSTS USANDO AJAX PARA FAZER O SITE RESPONDER VISUALMENTE AO CLICK.
VAMOS CRIAR O SISTEMA DE CHAT USANDO O CHANNELS, EU QUERO Q AS MENSAGENS SEJAM MANDADAS PARA UMA DATABASE.
O SISTEMA DO DISCOVERY VAI SER FEITO USANDO MEIO Q UM RANDOM USANDO PESOS, NO CASO SERIA ATRAVÉS DE HASHTAGS, SEGUIDORES E LIKES. 
PARA FINALIZAR O SITE PODEMOS CRIAR AS NOTIFICAÇÕES, EU TENHO DUAS IDEIAS PARA ISSO. UMA É USAR O CHANNELS PARA QUE VOCÊ CRIE UMA CONEXÃO COM SEU SEGUIDORES E CADA AÇÃO CRIA UM EVENTO E ELE É REPASSADO PARA AS OUTRAS CONEXÕES NO WEBSOCKET.
OUTRA OPÇÃO SERIA USAR AJAX PARA ATUALIZAR A PORÇÃO DE NOTIFICAÇÕES DA PAGINA PERIODICAMENTE E USAR SIGNALS PARA MANDAR AS NOTIFICAÇÕES PARA A SESSÃO.

BIBLIOTECAS INTERESSANTES, django_cleanup, django_resized


to usando >>> codigo  para indicar codigo no meio do texto, pra bater o olho mais rapido
nomeação de variaveis e de funções será feita com    app_nome_da_var
nomeação de classes serão feitas com     AppNomeDaClasse
nomeação de nomes em urls.py e classes de html são feitas com     nome-de-x


DIA 1-
 VOU CRIAR O PROJETO E JÁ COMEÇAR USANDO UMA DB POSTGRESQL, VAMO CRIAR O VENV E JÁ INSTALAR DJANGO E PSYCOPG2 E CRIAR A DATABASE. A database será blog_instagram e a senha é do server é kekorsauce. Agora criado o venv e instalado o django e psycopg, vou criar o projeto core. Vamos no SETTINGS.py e vamos mudar a var DATABASES para DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': 'blog_instagram', 
        'USER': 'postgres', 
        'PASSWORD': 'kekorsauce',
        'HOST': 'localhost', 
        'PORT': '5432',
    }
}
Agora vamos criar o app users e o app blog, vou por enq só fazer uma home mostrando se o usuario ta logado ou nn e  não vou usar as loginview e logoutview porque pelo visto elas vao ser removidas no django 5.0, então vamos fazer as views e pra isso vamos usar algumas funcs novas:
-authenticate(username=x, password=y), essa aqui verifica se tem algum User com os atributos q vc passou, como password , email e/ou senha
-login(request, user) apos autentcar o user, vc passa no login e pronto, ta logado
-logout(request) essa só desloga o user
Então basta criar as views de login, logout e register. Vou começar fazendo uma pagina simples no blog onde só mostra um texto falando se ta logado ou não.
Eu tava querendo criar um grande static file que segurasse todos static fora dos apps, mas pelo visto o django tem um comando collectstatic que cuida disso, então vou fazer o metodo normal de cada app ter o --> static/appp/x.css  então vamos no settings.py e usar >>> STATIC_URL = 'static/'  e depois sempre o {% load static %}
Settado as urls para os app e criado a home page e colocado os apps no settings.py,  vamos criar a register view.
>>> from django.contrib.auth import logout, login, authenticate		para importar as funções que serão usadas nas views. Para registrar vamos pegar informações da de uma form, autenticar o usuario e cria-lo caso seja valido. PASSEI O DIA INTEIRO SOFRENDO, MAS CONSEGUI TER UM BOM ENTENDIMENTO EM FORMS.
vamos fazer uma modelForm normal, adicionando os fields, a class Meta e por fim a validação
>>>  Class TesteForm(forms.ModelForm):
	field1 = forms.CharField(widget=forms.TextInput(attrs={'atribute': 'value'}))
	field2 ...
	
	class Meta:
	   model = Model         <-- isso define o modelo q será usado
	   fields = ['field1', 'field2'] 	<-- isso define a ordem q os fields aparcem no Html
	
	def clean_field1(self):        
	   test = self.cleaned_data['field1']
	   if x:                                        <-- aqui ta um ex de clean_<field> method
	      raise Validation Error('x aconteceu')
	   else:
	      return test

	def clean_<field>(self):    <-- o return é o field escolhido
	   ## validação ##

	def clean(self):			    <-- o clean method é usado para validar vários fields e segue o esquema do exemplo acima
	   ## validação de multiplos fields ##      <-- aqui o return é um self.cleaned_data completo
	
	def save(self):
	   ## pega data, cria modelo, salva modelo e retorna modelo ##     <-- aqui é usado caso você queria salvar o modelo, como no register
Iso foi o que eu consegui acumular hj no quesito Forms, widgets são representações de html, class meta define modelo e ordem de fields, as validações ou fazem o form passar no .is_valid() ou no caso de raise, volta a pagina com uma mensagem de escolha, o save vai ativar o .save() method do Model com os valores inputados.
Na view do register eu peguei a form e capturei o Model retornado no .save() numa var e usei o login() e um redirect().
Na view do login eu chequei o .is_valid() depois pegue o form.cleaned_data['field'] para usar no authenticated(), que cria um user, e então usar o login() no user.
Na view do logout eu apenas user logout() e dei redirect().


DIA 2-
 Agora eu vou usar os Signals para criar um modelo Profile. Criei um modelo UsersProfile com os fields user, pfp, bio e name. Agora vamos fazer os sigals-
>>> 	from django.dispatch import receiver
	from .models import UsersProfile
	from  django.db.models.signals import post_save
	from django.contrib.auth.models import User

	@receiver(post_save, sender=User)                            <-- aqui fica a se vai ser antes ou depois do save() e sender, que é qual Model ativa o evento
	def create_profile(sender, instance, created, **kwargs):     <-- created é um bool, instance é a instancia do modelo q ativou o evento
 	   if created:						     <-- o tutorial q eu vi separa assim os dois signals, ent to fazendo assim
 	       UsersProfile.objects.create(user=instance)

	@receiver(post_save, sender=User)
	def save_profile(sender, instance, **kwargs):
	    instance.profile.save()
Depois é necessário ir no apps.py e adicionar esse método na class
>>>	def ready(self):
            import users.signals
Eu cofigurei no settings.py >>> MEDIA_URL =  'media/' >>> MEDIA_ROOT = os.path.join(BASE_DIR, 'media') e adicionei o snippet da doc no urls.py do core.
				NÃO ESQUECE DE COLOCAR A PORRA DO .first() QUANDO ESTIVER FAZENDO QUERIES
Eu fiz uma form simples para alterar o profile e fiz uma view, algo importante para lembrar é que deve-se ter Form(request.POST, request.FILES, instance=xyz) para que  a form receba as info do post, os arquivos e a instancia do modelo qnd foi pego. Para finalizar é preciso ter uma <form method="post" enctype="multipart/form-data">.
To usando o >>> 'django_cleanup.apps.CleanupConfig' no INSTALLED_APPS e parece q isso exclui imagens antigas qnd vc sobe uma nova. Vai ter que baixar o django cleanup usando >>> pip install django-cleanup.
Pra finalizar por agora a parte de users e partir pra criar os posts, likes, comments e followers, vamos apenas adicios os @login_required nas páginas
>>> from django.contrib.auth.decorators import login_required.
Criei um model e form para os Posts com image, profile, desc, date e ficou assim:
>>>  class BlogPosts(models.Model):
    	profile = models.ForeignKey(UsersProfile, on_delete=models.CASCADE)
    	image = ResizedImageField(size=[500, 1500], upload_to='post_images')
    	desc = models.CharField(max_length=255)
    	date = models.DateField(default=date.today())
na image foi usado um regulador para o tamanho das imagens usando a biblioteca 
django-resized >>> pip install django-resized veja a página no github, mas o uso vai ser no lugar do >>> models.ImageField , vc usa 
>>> ResizedImageField(size=[500, 300], upload_to=get_image_path)
Agora ta legal, mas ta começando a ficar bem confuso visualmente, então amanhã eu vou fazer o frontend disso tudo. Vou ter que planejar como esquematizar os templates e criar um sistema de nomeação pra ficar menos confuso, além de separar o css em vários arquivos para melhorar a leitura.


DIA 3- 
Criei uma table de follower onde recebe follower e follower, isso foi usado pra parsear os posts e colocalos numa lista 
>>> post_utils_list = [
        [post_obj, like_form, ...],
        [post_obj, like_form, ...],
        ...
    ]
Isso deixa aberto para quando eu fizer os comment e likes. Agora foi feito a parte visual do header q vai ser usado em quase todas páginas e fiz os posts, só falta agora fazer a parte de criar posts e o login-regiser pra passar pra fazer a página de profile usano ajax.


DIA 4- 
ACABEI fiz o visual do register,login,home,profile e profile update. Agora tá tudo bem no rumo pra eu conseguir fazer os btn de follow e adicionar o sistema de like.


DIA 5-
 Eu importi jquery, já que vai ser útil mais pra frente no projeto
>>> <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
Hoje eu criei os popup de lista de followers no profile e depois parti para fazer os botoes de follow e unf.
pra isso eu criei um app AJAX e usei ele para lidar com o save() e delete(), a view ficou assim.
>>>     from users.forms import UsersFollowersForm
	from django.http import JsonResponse
	from django.core import serializers
	from django.views.decorators.csrf import csrf_exempt
	from users.models import UsersFollowers
	# Create your views here.
	@csrf_exempt
	def AjaxProfileFollow(request):
	    if request.method == 'POST':     <- recebe o post q foi mandado pelo ajax
	        form = UsersFollowersForm(request.POST)
	        if form.is_valid():
	            instance = form.save()
	            # serializar é transforma info pra o ajax joga pro outro lado
	            ser_instance = serializers.serialize('json', [instance,])
	            return JsonResponse({"instance": ser_instance}, status=200)  <- devolve pro success no json
	        else:
	            return JsonResponse({"error": form.errors}, status=400)
	    else:
	        return JsonResponse({"error": form.erros}, status=400)
	        # 200 deu certo, 400 deu nn
Agora a parte do Ajax no front q manda e recebe os pedido
<script>
        $('.users-profile-follow-form').on('submit', function(e){     <- seleciona a form q vai manda info
            console.log('houve click')
            // pelo visto essa parte do 'e' é pra n da reset na pag   <- o eu do passado estava correto
            e.preventDefault();
            // serializar pra jogar pro url do app ajax
            var serializeData = $(this).serialize();   
            $.ajax({
                type:'POST',                           <- aqui é metodo post pra receber no back
                url: '{% url "profile-follow" %}',	<- aqui indica a view q recebe o post
                data: serializeData,			<- a info q vai ser mandada
                success: function(response){		<- no succes é oq vai ser feito qnd da certo
                    $(".users-profile-header-info-numbers-wrapper").load("{% url 'profile' profile.user.pk %}  .users-							                   profile-header-info-numbers", function(){
                        let followBtn = document.querySelector('.users-profile-header-info-follow')
                        let unfollowBtn = document.querySelector('.users-profile-header-info-unfollow')
                        followBtn.style.display = 'none'
                        unfollowBtn.style.display = 'inline-block'
                    });
                },
                error: function(response){
                    console.log('erro')
                }
            });
        })
    </script>
Hoje a noite eu vou deixar tudo certinho, pq ainda preciso dar condição nos botoes, adicionar e remover o profile do user das listas meio q manual já q dar reload nas listas n ta funcionando e depois colcoar as sugestões na home.
Vamos ver se sobra tempo também para começar os likes/comments.
Coloquei condição nos btns, se o request.user.profile in followers ai esconde o botão de follower, ai nos eventlistener do ajax ele troca o botão que aparece, roda as funções que adicionam o click nas popup e usa $(x-div).load({% url 'profile' profile.user.pk %} y-div) para atualizar a lista do popup.
Hoje tava meio duro de tempo, então a parte sugestão de followers eu faço amanhã(hj né oq já é 0:35) e começo a parte dos like/comment.


DIA 6/7- Criei o sistema de sugestão usando a biblioteca RANDOM do python. 

DIA 8- DESCOBRI UM ERRO BRUTAL NO CÓDIGO, bem a form q eu fiz foi usando password1 e 2, mas nenhuma password normal, então quando eram salvos os user, não tinham senhas e por isso n era possivel achar eles pelo authenticate(), a solução é na view salvar o modelo e guardar o return numa var e mudar a senha e salvar denovo.
>>> user = form.save()
    user.set_password(form.cleaned_data['password1'])
    user.save()

DIA 9- Criei os modelos simples de like que recebe user e o post, atualizei a postlist para 
post_list = [] # -> 0-posts_obj, 1-likeform, 2-like obj, 3-is_liked , 4-index 5-commentform, 6-comment obj, 7-commetfirst
foi adicionado o is_liked e o index, index é só usado pra diferenciar o wrapper do post e o is_liked é usado pra mostrar qual das duas forms vai ser rendenizada e eu adicionei as forms simples no post. 
AGORA UMA PARTE INTERESSANTE eu tive a ideia de englobar tudo que tange ao post dentro de um wrapper, isso inclui o proprio post normal q aparece na home com as forms de like e comment, os popup mostrandos os users que deram like e a superpopup do post quando você clica nele. Minha preocupação é que isso tudo vai estar num wrapper q vai estar dentro de um ajaxwrapper e quando o ajax for dar load nessa porra toda, pode ficar bem lerdo.
Agora sobre o codigo por tras do botão de like, primeiro de volta na ajax.views eu coloquei uma função simples de criar instancia de like e uma de remover.
Na parte do template eu coloquei o código:
<script>
        var funcLike = function(thisx){
            thisx.on('submit', function(e){
                console.log('houve click')
                // pelo visto essa parte do 'e' é pra n da reset na pag
                e.preventDefault();
                // serializar pra jogar pro url do app ajax
                var serializeData = thisx.serialize();
                $.ajax({
                    type:'POST',
                    url: '{% url "post-like" %}',
                    data: serializeData,
                    context: thisx,
                    success: function(response){
                        let wrapperAjaxDOM = $(this).parents().eq(4)
                        let wrapperAjax = '.' + $(this).parents().eq(4).attr('class')
                        let wrapper = '.' + $(this).parents().eq(3).attr('class')
                        $(wrapperAjax).load("{% url 'home' %}" + ' ' + wrapper, function(){
                            funcUnlike(wrapperAjaxDOM.find('.post-unlike-form'))
                        })
                    },
                    error: function(response){
                        console.log('erro')
                    }
                });
            })
        }
        var funcUnlike = function(thisy){
            thisy.on('submit', function(e){
                console.log('houve click')
                // pelo visto essa parte do 'e' é pra n da reset na pag
                e.preventDefault();
                // serializar pra jogar pro url do app ajax
                var serializeData = thisy.serialize();
                $.ajax({
                    type:'POST',
                    url: '{% url "post-unlike" %}',
                    data: serializeData,
                    context: thisy,
                    success: function(response){
                        let wrapperAjaxDOM = $(this).parents().eq(4)
                        let wrapperAjax = '.' + $(this).parents().eq(4).attr('class')
                        let wrapper = '.' + $(this).parents().eq(3).attr('class')
                        $(wrapperAjax).load("{% url 'home' %}" + ' ' + wrapper, function(){
                            funcLike(wrapperAjaxDOM.find('.post-like-form'))
                        })
                    },
                    error: function(response){
                        console.log('erro')
                    }
                });
            })
        }


        $('.post-like-form').each(function(){
            funcLike($(this))
        })
        $('.post-unlike-form').each(function(){
            funcUnlike($(this))
        })
    </script>
    <!--
        A solução foi incrivelmente simples, só selecionar o wrapper do post q foi reloadado e selecionar o filho q vc quer, o problema q eu tava tendo foi q eu tava selecionando td isso fora do callback da load e é necessário fazer isso no .load(). Fica meio confuso de ler porque ta referenciando as funções entre si, mas jpa q js é async funciona legal. Gostei bem dessa parte, mas n vai ter jeito, vou ter que refatorar saporra pq ta um inferno ficar rodando por 300linhas de cógido toda hora.
    -->
copiei tmb a explicação q eu coloquei, pode ser útil no futuro. Aqui eu fiz o ajax um pouco diferente, eu crie ele como eu faria antes dentro do .each(), mas depois eu fiz diferente, eu separei a função numa var que recebe o objeto jquery e usa o .on() nele e continua normalmente aí eu depois só chamo essa função, mas agora olhando eu vejo q eu posso deixar o .on() fora da função para deixar ela mais pura ainda, mas vou ver isso amanhã q é o dia do código refatorado. 
Ah e eu separei o ajax em funções pq é pra elas se chamarem entre si, como vc pode ver a funcLike tem funcUnlike dentro dela e a funcUnlike tem funcLike dentro dela, achei estranho essa relação simbiótica, mas ta funcionando e boa.
COISAS PARA VER AMANHÃ: QUERIA DIVIDIR O TEMPLATE EM MAIS PARTES, CRIAR UM METHODS.PY PARA DEIXAR O TRABALHO MAIS PESADO DAS VIEWS DENTRO DE LÁ E REFAZER OS AJAX COM FUNÇÕES, GOSTEI DISSO.


